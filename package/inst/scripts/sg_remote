#!/usr/bin/python
# -*- Mode:Python; indent-tabs-mode:t; tab-width:4; python-indent:4 -*-;

# script run by all remote dial-in sensorgnomes
#
# If sensorgnome ssh'd in using a factory key, then we read its
# serial number, and generate a new public key/private key pair
# and forwarding port number, which is returned to the client on stdout.
#
# Otherwise, sensorgnome ssh'd in using a key generated by the
# above, and we run the logger program.

import os
import re
import subprocess
import sys
import sqlite3
import time
import atexit
import fcntl
import io

SSH_DIR = '/home/sg_remote/.ssh/'
MASTER_SQLITE_DB = '/home/sg_remote/receivers.sqlite'
MASTER_SQLITE_DB_LOCK = '/home/sg_remote/receivers.sqlite.lockfile'

STREAMS_PATH = '/home/sg_remote/streams'

# valid serial numbers look like this:
SERIAL_NO_REGEX = re.compile(r'^[A-Za-z0-9]{12}$')

# valid data or metadata stream lines look like this:
STREAM_LINE_REGEX = re.compile(r'^[-#@a-zA-Z0-9,.+;: /"]{1,100}$')

CONNECTION_FLAG_PATH = '/home/sg_remote/connections/'
MIN_TUNNEL_PORT = 40000
MAX_TUNNEL_PORT = 49999

os.umask(002)

# import serial number from environment; comes from the line in
# .ssh/authorized_keys corresponding to the key used to log into
# the current session

serno = os.environ['SG_SERNO']

# if the client used the factory key, the serno is 'new'

ff = open("/home/sg_remote/log.txt", "a")
ff.write("%d,%s\n" % (time.time(), serno))

if serno == "new":
    # new login; ask the client for the serial number

    serno = sys.stdin.readline(13).rstrip()

	# kludge to allow specific device to connect during 3.18 kernel work
	if serno == "":
		serno = "2313BBBK3402"
    # the serial number is supposed to be a string of 12 alphanumeric
    # chars (we read the trailing byte)

    if not SERIAL_NO_REGEX.match(serno):
        print ("FAILED")
        ff.write("Failed with serno %s\n" % (serno, ))
        ff.close()
        exit(1)

    keyfile_name = SSH_DIR + "id_dsa_sg_" + serno

    # this is supposed to be the first login for this sensorgnome.
    # If not, we fail.

    # NOTE: do not return the public/private key pair that already
    # exists for this sensorgnome - that would be giving away the
    # store!  If an SG has lost its keys, then manual intervention is
    # required: the existing keys must be sent to the SG user.

    # Otherwise, anyone with the factory keys can get the
    # public/private keys for any SG by simply providing its serial
    # number.  The point is we want to allow each SG to start
    # with the same factory key, and end up with its own keys, which
    # are known to the server.

    if os.path.exists(keyfile_name):
        print ("FAILED")
        ff.write("Failed with keyfile_name %s\n" % (keyfile_name, ))
        ff.close()
        exit(2)


	# open the master DB as a file, so we can lock it
	dbf = open(MASTER_SQLITE_DB_LOCK, "w")
    try:
	# wait for an exclusive lock on the DB
		fcntl.lockf(dbf.fileno(), fcntl.LOCK_EX)
		ff.write("Got lock\n")
		conn = sqlite3.connect(MASTER_SQLITE_DB, isolation_level="EXCLUSIVE")

		curs = conn.cursor()

	    # create the receivers table if it does not already exist
	    if curs.execute('select count(*) from sqlite_master where type="table" and name="receivers"').fetchone()[0] == 0:
	        curs.execute('''
  	create table receivers (
	    serno        text unique primary key, -- only one entry per receiver
	    creationdate real,                    -- timestamp when this entry was created
	    tunnelport   integer unique,          -- port used on server for reverse tunnel back to sensorgnome
	    pubkey       text,                    -- unique public/private key pair used by sensorgnome to login to server
	    privkey      text,
	    verified     integer default 0        -- has this receiver record been validated (do we know it's not a phony e.g. an attack on the server?).  No data from the receiver's database should be used anywhere until this field is true (non-zero)
	)
	''')

	    # generate a port number for tunnelling back into the receiver

	    port = curs.execute('select 1+max(tunnelport) from receivers').fetchone()[0]
	    if port == None:
	        port = MIN_TUNNEL_PORT
	    elif port >= MAX_TUNNEL_PORT:
	        print ("FAILED")
	        conn.close()
	        ff.write("Failed with port %d\n" % (port, ))
	        ff.close()
	        exit(2)

	    # generate a pub/priv keypair

	    subprocess.check_output([
			"ssh-keygen",
			"-t", "dsa",
			"-f", keyfile_name,
			"-N", ""
		])

	    # export an openssl-compatible version of the public key
		# for use in signature verification
		# sample command: openssl dsa -in ~sg_remote/.ssh/id_dsa_sg_2814BBBK4765 -pubout -out ~sg_remote/.ssh/id_dsa_sg_2814BBBK4765.openssl.pub

	    subprocess.check_output([
			"openssl",
			"dsa",
			"-in", keyfile_name,
			"-pubout",
			"-out", keyfile_name + ".openssl.pub"
		])

	    # read keys
	    priv_key_file = open(keyfile_name, "r")
	    priv_key = ''.join(priv_key_file.readlines()) # multiple lines
	    priv_key_file.close()

	    pub_keyfile_name = keyfile_name + ".pub"

	    pub_key_file = open(pub_keyfile_name, "r")
	    pub_key = ''.join(pub_key_file.readlines()) # probably a single line
	    pub_key_file.close()

	    # add a record for this sensorgnome
	    curs.execute('insert into receivers values (:serno, :creationdate, :tunnelport, :pubkey, :privkey, :verified)', {
	            "serno": serno,
	            "creationdate": time.time(),
	            "tunnelport": port,
	            "pubkey": pub_key,
	            "privkey": priv_key,
	            "verified": 1    ## FIXME: change this to zero once compudata testing is complete
	            })

	    auth_key_file = open(SSH_DIR + "authorized_keys", "a")
	    # restrict this key to running sg_remote and only mapping a single remote port
	    # local port mapping is restricted to reach port 7 on the host, which if it
	    # is even available is the echo port.  This means even if someone gets
	    # hold of a unique pub/priv key pair for a sensorgnome, at most they can
	    # fill up an sqlite database with junk, and can't connect to any services
	    # on the host.

	    auth_key_file.write('command="/home/sg_remote/code/sg_remote"'
	                        ',no-pty'
	                        ',no-X11-forwarding'
	                        ',single-remote-forwarding-port=%d'
	                        ',permitopen="localhost:7"'
	                        ',environment="SG_SERNO=%s" %s' % (port, serno, pub_key))
	    auth_key_file.close()

	    sys.stdout.write('%d\n%s%s' % (port, pub_key, priv_key))

	    conn.commit()
	    conn.close()

    except Exception:
        exctype, value = sys.exc_info()[:2]
        ff.write("Got exception: type=%s, value=%s\n" % (exctype, value));

    # release the DB lock
    fcntl.lockf(dbf.fileno(), fcntl.LOCK_UN)
    ff.write("Unlocked\n")
    ff.close()
    dbf.close()

    exit(0)

else:
    # touch a file indicating SG is connected

    flag_file = CONNECTION_FLAG_PATH + serno
    if not os.path.exists(flag_file):
        open( flag_file, "w").close()
        atexit.register( lambda f : os.remove(f), flag_file )
    else:
        open ( "/tmp/sshd_sg_log.txt", "a").write("Rejection @%.3f from %s\n" % (time.time(), serno, ))
        exit(3)

    conn = sqlite3.connect(STREAMS_PATH + '/' + serno + '.sqlite')

    conn.execute('pragma journal_mode=WAL;')
    conn.executescript('''
create table if not exists connections (
    serverts   double,     -- timestamp on server at receiver connection
    state      integer     -- 1: connected, 0: disconnected
);

create index if not exists connections_serverts on connections (serverts);

create table if not exists gps (
    serverts   double,     -- timestamp server received record
    ts         double,     -- gps timestamp
    lat        double,     -- latitude, decimal degrees
    lon        double,     -- longitude, decimal degrees
    alt        double      -- altitude, metres
);

create index if not exists gps_ts on gps ( ts );

create table if not exists metadata (
    serverts  double,           -- timestamp server received record
    ts        double,           -- receiver timestamp
    parname   text,             -- name of parameter (e.g. bootcount, tscode)
    parval    double            -- value of parameter
);

create index if not exists metadata_ts on metadata ( ts );
create index if not exists metadata_parname on metadata ( parname );

create table if not exists devices (
    serverts  double,           -- timestamp server received record
    action    text,             -- 'A' for add, 'R' for remove
    ts        double,           -- receiver timestamp
    port      integer,          -- port device was added/removed to/from
    type      text,             -- device type
    path      text              -- path to device symlink, including attributes
);

create index if not exists devices_ts on devices ( ts );
create index if not exists devices_port on devices ( port );

create table if not exists params (
    serverts  double,           -- timestamp server received record
    ts        double,           -- param setting timestamp
    port      integer,          -- hub port -- for which device setting applies
    param     text,             -- parameter name
    val       double,           -- parameter setting
    error     integer,          -- 0 if parameter setting succeeded; error code otherwise
    errinfo   character         -- non-empty if error code non-zero
);

create index if not exists params_ts on params ( ts );

create table if not exists taghits (
    serverts   double,        -- timestamp server received record
    port       integer,       -- hub port -- which device did this tag get identified on?
    ts         double,        -- timestamp from filename (time at which file was created)
    tagID      text,          -- tag id (full, with ID, freq, BI )
    freq       double,        -- apparent tag frequency offset in kHz
    freqsd     double,        -- standard deviation of frequency offset for pulses in burst
    sig        double,        -- signal level in dB
    sigsd      double,        -- signal level SD, in percent
    noise      double,        -- noise level in db
    slop       double,        -- mean absolute difference of gap size between hit and database
    burstSlop  double         -- mean absolute difference between most recent burst interval and database
);

create index if not exists taghits_ts on taghits ( ts );

create index if not exists taghits_id on taghits ( tagID );

create table if not exists unknown (
    serverts   double,        -- timestamp server received record
    msg        text           -- text of an unknown message
);

create index if not exists unknown_ts on unknown ( serverts );

''')

    atexit.register( lambda conn : (
            conn.execute('insert into connections values (?, ?)', (time.time(), 0)),
            conn.commit(),
            conn.close()
            ), conn)

    conn.execute('insert into connections values (?, ?)', (time.time(), 1))
    conn.commit()

    while True:
        # for now, limit input lines to 100 chars + '\n'
        x = sys.stdin.readline(101)

        # check for remote hang-up
        if len(x) == 0:
            exit(1)

        # strip trailing whitespace and check for clean characters
        # (if someone pushes us bogus data after a fake registration, we don't
        # want anything dangerous leaking through to html pages or whatever)

        x = x.rstrip()
        if not STREAM_LINE_REGEX.match(x):
            continue

        x = x.split(',')

        if len(x) == 0 or len(x[0]) == 0:
            continue

        serverts = time.time()
        if x[0][0] == 'G' and len(x) == 5:
            # GPS message:  G,timestamp,lat,lon,alt
            # e.g.: G,1378780031,44.687745,-63.145695,9.7
            conn.execute("insert into gps values (?, ?, ?, ?, ?)",
                         (serverts, ) + tuple(x[1:]))

        elif x[0][0] == 'S' and len(x) == 7:
            # Parameter setting message: S,timestamp,ant,param,val,exitCode,errMsg
            # e.g.: S,1378781399.888,3,-m,166.376,0,
            conn.execute("insert into params values (?, ?, ?, ?, ?, ?, ?)",
                         (serverts, ) + tuple(x[1:]))

        elif x[0][0] == 'M' and len(x) == 4:
            # Metadata message: M,timestamp,parname,parval
            # e.g.: M,1378781399.888,bootcount,11
            conn.execute("insert into metadata values (?, ?, ?, ?)",
                         (serverts, ) + tuple(x[1:]))

        elif x[0][0] == 'C' and len(x) == 4:
            # Clock setting message: C,timestamp,precision,elapsed
            # e.g.: C,1378781399.888,0.001,12352
            conn.execute("insert into metadata values (?, ?, ?, ?)",
                         (serverts, x[1], "clockSetPrecision", x[2]))
            conn.execute("insert into metadata values (?, ?, ?, ?)",
                         (serverts, x[1], "clockSetElapsed", x[3]))

        elif (x[0][0] == 'A' or x[0][0] == 'R') and len(x) == 5:
            # Device add/remove message: A/R,timestamp,port,type,devicePath
            # e.g.: A,1378781399.888,3,funcubeProPlus,funcubeProPlus.port=4.alsaDev=0.usbPath=1:7
            conn.execute("insert into devices values (?, ?, ?, ?, ?, ?)",
                         (serverts, ) + tuple(x))

        elif x[0][0].isdigit() and len(x) == 10:
            # Tag detection message: port,timestamp,fullID,freq,freqsd,sig,sigsd,noise,slop,burstSlop
            # e.g.: 2,13456722333.1423,481,4.123,0.022,-40.2,0.113,-70.2,0.0015,0.0012,166.38
            conn.execute("insert into taghits values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                         (serverts, ) + tuple(x))

        else:
            # unknown message
            conn.execute("insert into unknown values (?,?)",
                         (serverts, ','.join(x)))

            # don't allow big unknown streams to overwhelm us
            time.sleep(0.1)

        conn.commit()
