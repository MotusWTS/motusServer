% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sgSyncDBtoRepo.R
\name{sgSyncDBtoRepo}
\alias{sgSyncDBtoRepo}
\title{Make sure all files stored internally in a Sensorgnome receiver DB
are also present in the file_repo.}
\usage{
sgSyncDBtoRepo(serno, dbdir = MOTUS_PATH$RECV, repo = MOTUS_PATH$FILE_REPO,
  bkup = MOTUS_PATH$TRASH)
}
\arguments{
\item{serno}{receiver serial number}

\item{dbdir}{path to folder with existing receiver databases
Default: \code{MOTUS_PATH$RECV}}

\item{repo}{path to folder with existing receiver file repos
Default: \code{MOTUS_PATH$FILE_REPO}}

\item{bkup}{path to folder for storing replaced files as backup.  They will
be stored in a folder whose name is the receiver serial number
Default: \code{MOTUS_PATH$TRASH}}

\item{x}{tbl of linked records between db and repo}

\item{serno}{character scalar receiver serial number}

\item{repo}{path to file repo}

\item{bkup}{path to file backups}
}
\value{
a data.frame with these columns:
\itemize{
\item name - character; bare filename, without compression extension
\item status - integer; status of DB file; possible values:
\itemize{
\item 0: file already in repo and contents there of same size equal or larger than DB contents, so no action taken
\item 1: file already in repo but contents there were smaller than DB contents, so file replaced
and old copy sent to \code{oldrepo}
\item 2: file not in repo, so added to repo
}
}

Returns NULL if no valid data files were found.

integer status: 0=already in repo and not changed; 1=already in repo and updated; 2=not in repo and saved there
}
\description{
Any file which is either missing from the file repo (ignoring the
compression extension) or is present in the DB with longer contents
is copied from the DB to the file_repo, with the existing copy
getting moved to a backup folder.  The copied-out file is written
compressed and so given the .gz extension
}
\details{
To workaround at least this bug:
   https://github.com/jbrzusto/motusServer/issues/213
files are matched by (bootnum, timestamp), with a sanity check
examining the first 3 lines of any match.
}
\author{
John Brzustowski \email{jbrzusto@REMOVE_THIS_PART_fastmail.fm}
Treat each linked group of files between db and repo

A file in the db is linked to 0, 1, or 2 files in the repo;
this function receives a tbl of the linked rows and
handles them according to this baroque (rococco?) scheme:

\code{
      if file not in repo (i.e. is.na(name.y))
          write file to repo (as .gz if done in db, else as .txt)
          status = 2L
      else if done in DB
          if complete compressed file present in repo
             ## this is the typical case
             ## and can be checked quickly (with a tiny probability of error) by:
             4-byte "uncompressed size" tail of .gz file from repo == "size.x"
             status = 0L
          else
             ## repo has an incomplete or no version of the compressed file
             move repo .gz and .txt (if present) file(s) to backup location
             write file to repo (as .gz)
             status = 1L
      else ## not done in DB, but file in repo
          if uncompressed file in repo and size.x <= size.y
             ## repo has a text file and it's bigger than the db size,
             ## so db has nothing to add
             status = 0L
          else if completed compressed file in repo (use gzip -t)
             ## the repo already has a complete .gz file
             status = 0L
          else
             ## whatever is in repo is either not complete (.gz) or smaller than what
             ## db has, so replace with DB version as .txt file
             move repo .txt and .gz file(s) to backup location
             write file to repo (as .txt)
             status = 1L
  }
}

