% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tagview.R
\name{tagview}
\alias{tagview}
\title{tagview create a view of tag detections linked to all metadata.}
\usage{
tagview(db, dbMeta = db, minRunLen = 3, keep = TRUE)
}
\arguments{
\item{db}{dplyr src_sqlite to detections database, or path to
.sqlite file.  The database must have tables batches, hits,
runs.}

\item{dbMeta}{dplyr src to database with "tags", "projects",
"species", and "recvDeps" tables.  Default: \code{db}}

\item{minRunLen}{minimum number of hits in a run; runs with fewer
hits are dropped}

\item{keep}{should temporary tables be saved permanently in the
    detections database?

Default: FALSE.  See Note below.}
}
\value{
a read-only data_frame of tag detections.  This data_frame
    is an SQLite VIEW wrapped in a dplyr tbl(), and "lives" in
 the \code{db} object.
}
\description{
This function returns data_frames of tag detections.  These can
come from receiver databases or tag databases.  Metadata for projects,
tag, and receiver deployments are linked when available.
}
\author{
John Brzustowski \email{jbrzusto@REMOVE_THIS_PART_fastmail.fm}
Implementation details:

For both tags and receivers, deployment meta-data has to be looked up by hit timestamp;
i.e. we need the latest deployment record which is earlier than the hit timestamp.
i.e. we are joining the hit table to the tag deployment table by a timestamp on the hit
and a greatest lower bound for that timestamp in the deployment table.
It would be nice if there were an SQL "LOWER JOIN" operator, which instead of joining
on exact key value, would join a key on the left to its greatest lower bound on the right.
(and similary, an "UPPER JOIN" operator to bind to the least upper bound on the right.)
For keys with B-tree indexes, this would be as fast as an exact join.

We can instead code this as a subquery like so:

CREATE TABLE hits (ts double, tagID integer);
CREATE TABLE tagDeps (tsStart double, tsEnd double, tagID integer, info char);

   SELECT t1.*, t2.info from hits as t1 left join tagDeps as t2 on
   t2.tagID = t1.tagID and t2.tsStart = (select max(t3.tsStart) from
   tagDeps as t3 where t3.tagID=t2.tagID and t3.tsStart <= t1.ts and
   t3.tsEnd >= t1.ts)

This will yield NA for the 'info' field when there is no tag deployment covering the range.
Running EXPLAIN on this query in sqlite suggests it optimizes well.
}

