#' Reserve a block of consecutive primary keys in a motus transfer table.
#'
#' This function returns the first key value in a block of N consecutive
#' key values for the specified table.  These key values are atomically
#' reserved, and guaranteed not to collide with key values for any other
#' receiver.  This permits multiple processes to be pushing data to
#' motus (via populating the transfer tables) at the same time.
#'
#' Note: a record with the largest key value for the block, and default
#' values for other columns, is inserted into the table.
#'
#' @param src dplyr src_mysql to motus transfer table database
#'
#' @param table name of the table in which to reserve keys.
#'
#' @param key name of the key column in table \code{table}.  This
#'     column must be a INT (or BIGINT) PRIMARY KEY.
#'
#' @param n number of consecutive keys to reserve.  If negative, the
#' keys are reserved in descending order, starting at the smallest
#' available value.
#'
#' @param IDcol name of column in which value \code{ID} is placed.
#'     Placing a receiver-unique value in this column lets us retrieve
#'     the value for the \code{key} column.
#'
#' @param ID value unique across receivers that is placed in column
#'     \code{IDcol} to mark it as belonging to this receiver.
#'     Ideally, this is the motusRecvID key for this receiver.
#'
#' @return the first key value in the block.  For positive \code{n}, this
#' is the lowest key value in the block.  For negative \code{n}, this is
#' the highest key value. i.e. in both cases, keys are allocated in order
#' from closest to 0 to farther from 0.
#'
#' @examples
#'
#' ## return the first key in a block of 200 reserved in the batches table
#' motusReserveKeys(src_mysql(...), "batches", "batchID", 200, "motusRecvID", 1234)
#'
#'
#'
#' @author John Brzustowski \email{jbrzusto@@REMOVE_THIS_PART_fastmail.fm}

motusReserveKeys = function(src, table, key, n, IDcol, ID) {
    sql = function(...) dbGetQuery(src$con, sprintf(...))

    ## insert a new record at the last new key value we want in the block
    ## the entire query, including nested select, is atomic, so if
    ## multiple processes are trying to reserve blocks, they won't
    ## overlap

    if (n > 0) {
        sql("insert into %s (%s, %s) select ifnull(max(%s),0) + %g, %g from %s",
            table, key, IDcol, key, n, ID, table)
    } else if (n < 0) {
        sql("insert into %s (%s, %s) select ifnull(min(%s),0) + %g, %g from %s",
            table, key, IDcol, key, n, ID, table)
    } else {
        stop("must reserve a non-zero number of keys")
    }

    ## we've now inserted a bogus record with the last key value for
    ## the reserved block.  The block is reserved by having the
    ## above query being the only way in which clients obtain new
    ## key values for the table.

    ## we now need to obtain the key for the first record in the block.
    ## This is where the ID and IDcol are used, since we can't use
    ## e.g. LAST_INSERT_ID(), because that is only set when a key
    ## value is generated by AUTO INCREMENT.
    ## Hopefully this way of phrasing the query plays nicely with
    ## MySQL's query optimizer

    if (n > 0) {
        return (sql("select %s from %s where %s=%s order by %s desc limit 1",
                    key, table, IDcol, ID, key) [[1]] - n + 1)
    } else {
        return (sql("select %s from %s where %s=%s order by %s limit 1",
                    key, table, IDcol, ID, key) [[1]] - n - 1)
    }
}
