#' watch for and enqueue uploaded files
#'
#' Watch for new files in \code{MOTUS_PATH$UPLOADS};
#' and when a new file is found, queue a job to process it.
#'
#' @param tracing logical scalar, default FALSE.  If TRUE, enter
#'     debug browser before handling each new file upload.
#'
#' @param fileEvent character scalar; default: "ATTRIB".  The
#' last filesystem event generated by the external program which
#' is placing files in the \code{MOTUS_PATH$UPLOADS} folder.
#' For other upload systems, the appropriate event might be "CLOSE_WRITE"
#' or "MOVED_TO".  The event should only occur once per uploaded file
#' and only after the full file contents are available.
#'
#' @return This function does not return; it is meant for use in an R
#'     script run in the background.  After each subjob is handled,
#'     the function checks for the existence of a file called
#'     \code{MOTUS_PATH$INBOX/killE}.  If that file is found,
#'     the function calls quit(save="no").  The file will also
#'     be detected within the call to feed() when the queue
#'     is empty, because it is located in the watched folder.
#'
#' @note this depends on some other process placing uploaded files into
#' the folder \code{MOTUS_PATH$UPLOADS}.  We're using:
#' \link{http://http://www.projectsend.org}
#' whose last event for an uploaded is "ATTRIB".
#'
#' @export
#'
#' @author John Brzustowski \email{jbrzusto@@REMOVE_THIS_PART_fastmail.fm}

uploadServer = function(tracing = FALSE, fileEvent="ATTRIB") {
    if(tracing)
        options(error=recover)

    ensureServerDirs()
    motusLog("Upload server started")

    ## load jobs
    loadJobs()

    ## get a feed of uploads; the last file event on an upload is "attrib",
    ## so we watch for that.

    feed = getFeeder(MOTUS_PATH$UPLOAD, messages = fileEvent, tracing=tracing)

    ## kill off the inotifywait process when we exit this function
    on.exit(feed(TRUE), add=TRUE)

    ## the kill file; must be in the same folder as passed to getFeeder,
    ## so that creating the killFile causes a return from feed() below:

    ## We don't want to let users kill this server by upload a file with this name,
    ## so the killFile functionality is disabled for this server, preventing graceful
    ## termination when the server is waiting for inotifywait to report a new upload

    ## killFile = file.path(MOTUS_PATH$INBOX, "killUploads")

    repeat {
        upfile = feed()    ## this might might wait a long time

        ## disabled killFile functionality (see above)
        ## if (upfile == killFile)
        ##     break

        if (tracing)
            browser()

        ## create and enqueue a new email job
        ## FIXME: change replyTo to match upload user's email
        j = newJob("uploadFile", .parentPath=MOTUS_PATH$INCOMING, replyTo=MOTUS_ADMIN_EMAIL, valid=TRUE, .enqueue=FALSE)

        ## record receipt within the job's log
        jobLog(j, paste("File uploaded:", basename(upfile)))


        jpath = file.path(jobPath(j), "upload")
        dir.create(jpath)
        ## move file to the job's dir

        file.rename(upfile, file.path(jpath, basename(upfile)))

        ## move the job to the mail queue, since it's the email server that processes
        ## unpacking archives and sanity checks on new files

        j$queue = "0"
        moveJob(j, MOTUS_PATH$QUEUE0)

        cat("Job", unclass(j), "has been entered into queue 0\n")

        ## disabled killFile functionality (see above)
        ## if (file.exists(killFile))
        ##     break
    }
    motusLog("Upload server stopped")
    quit(save="no")
}
