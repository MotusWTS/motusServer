#' Merge a batch of Lotek .DTA files with an existing database.
#'
#' @param files either a character vector of full paths to files, or the full
#' path to a directory, which will be searched recursively for .DTA files.
#'
#' @param dbdir path to folder with existing receiver databases; defaults
#' to \code{MOTUS_PATH$RECV}
#'
#' @return a data_frame reporting the fate of each file, with these columns:
#' \enumerate{
#' \item fullname - full path to filename
#' \item nameNew  - TRUE iff file of this name was not yet in database
#' \item dataNew  - TRUE iff file with these contents was not yet in database
#' \item use      - TRUE iff file copied to database
#' \item err      - if not NA, any error message generated by trying to parse the file
#' \item serno    - serial number (e.g. "Lotek-1234") of receiver this file is from
#' \item ts       - first timestamp from a detection in this file
#' \item tsLast   - last timestamp from a detection in this file
#' }
#'
#' @note If err is not NA for a file, then other fields for that file
#'     might not be set appropriately in the return value.
#'
#' @details Any files which are not identical to an existing file are saved
#' in the file repository at \code{MOTUS_PATH$FILE_REPO}, in addition to
#' being stored internally in the receiver database.  The names will be
#' modified if necessary to avoid collisions with existing files.
#'
#' Remaining files are deleted.
#'
#' @export
#'
#' @author John Brzustowski \email{jbrzusto@@REMOVE_THIS_PART_fastmail.fm}

ltMergeFiles = function(files, dbdir=MOTUS_PATH$RECV) {
    if (! isTRUE(is.character(files) && all(file.exists(files)))) {
        warning("invalid or non-existent input files specified")
        return()
    }
    if (file.info(files[1])$isdir)
        ff = dir(files, recursive=TRUE, full.names=TRUE, pattern=".*\\.dta$", ignore.case=TRUE)
    else
        ff = sort(files)

    rv = data_frame(fullname = ff, nameNew = TRUE, dataNew = TRUE, use = FALSE, err = NA, serno = as.character(NA), ts = as.numeric(NA), tsLast = as.numeric(NA))

    for (i in seq(along=ff)) {
        f = ff[i]
        size = file.info(f)$size
        blob = readBin(f, raw(), n=size)
        ll = (blob %>% rawToChar %>% strsplit("\r\n", fixed=TRUE)) [[1]]
        skip = FALSE
        x = NULL
        tryCatch({
            x <- readDTA(lines=ll)
            rv$serno[i] = x$recv
            if(nrow(x$tags) > 0) {
                tsr = range(x$tags$ts)
                rv$ts[i] = tsr[1]
                rv$tsLast[i] = tsr[2]
            }
        }, error = function(e) {
            rv$err[i] = as.character(e)
            skip <- TRUE
        })
        if (skip)
            next

        ## lock the receiver DB

        lockSymbol(x$recv)

        ## make sure we unlock the receiver DB when this function exits, even on error
        ## NB: the runMotusProcessServer script also drops any locks held by a given
        ## processServer after the latter exits.

        on.exit(lockSymbol(x$recv, lock=FALSE))

        src = getRecvSrc(x$recv)

        ## compute file hash, then check whether it already is in database
        fhash = digest(blob, algo="sha512", serialize=FALSE)

        files = tbl(src, "DTAfiles")

        bname = basename(f)
        if (files %>% filter(name==bname) %>% count %>% as.data.frame > 0) {
            rv$nameNew[i] = FALSE
        }

        this = files %>% filter(hash==fhash)

        if (this %>% count %>% as.data.frame > 0) {
            rv$dataNew[i] = FALSE
        } else {

            comp = memCompress(blob, type="bzip2")

            ## sqlite connection

            con = src$con

            ## write meta data

            meta = getMap(src)

            meta$dbType = "receiver" ## indicate this is a receiver database (vs. a tagProject database)
            meta$recvSerno = x$recv
            meta$recvType = "Lotek"
            meta$recvModel = getLotekModel(x$recv)

            ## write file record
            dbGetPreparedQuery(
                con,
                "insert into DTAfiles (name, size, tsBegin, tsEnd, tsDB, hash, contents) values (:name, :size, :tsBegin, :tsEnd, :tsDB, :hash, :contents)",
                data_frame(
                    name     = bname,
                    size     = length(blob),
                    tsBegin  = min(x$tags$ts),
                    tsEnd    = max(x$tags$ts),
                    tsDB     = as.numeric(Sys.time()),
                    hash     = fhash,
                    contents = list(comp) ## NB: make list, else dataframe replicates entire row for each byte!
                ) %>% as.data.frame
            )
            rv$use[i] = TRUE
            fid = dbGetQuery(con, "select max(fileID) from DTAfiles")[[1,1]]

            ## write tags records

            ## FIXME: it would be nice to factor out antenna frequency,
            ## codeset, gain, lat/lon as we do for SG records.  This would
            ## make for much smaller data files.  But we can't do this by
            ## timestamp, as these can jump around significantly in the
            ## .DTA files, and so must use file (lexical) order.

            if (isTRUE(nrow(x$tags) > 0)) {
                dbGetPreparedQuery(
                    con,
                    "insert or ignore into DTAtags (fileID, dtaline, ts, id, ant, sig, lat, lon, antFreq, gain, codeSet) values (:fileID, :dtaline, :ts, :id, :ant, :sig, :lat, :lon, :antFreq, :gain, :codeSet)",
                    data_frame(
                        fileID  = fid,
                        dtaline = x$tags$dtaline,
                        ts      = x$tags$ts,
                        id      = x$tags$id,
                        ant     = x$tags$ant,
                        sig     = x$tags$sig,
                        lat     = x$tags$lat,
                        lon     = x$tags$lon,
                        antFreq = x$tags$antfreq,
                        gain    = x$tags$gain,
                        codeSet = x$tags$codeset
                    ) %>% as.data.frame
                )
            }
        }
        ## unlock the receiver and drop the source
        lockSymbol(x$recv, lock=FALSE)
        rm(src)
        gc(2)
    }

    ## save any files used in the receiver's folder in the file repo
    for (recv in unique(rv$serno)) {
        move = subset(rv, serno==recv & use)$fullname
        if (length(move) > 0)
            moveFilesUniquely(move, file.path(MOTUS_PATH$FILE_REPO, serno))
    }

    ## delete all remaining files
    toTrash(ff)
    return (rv)
}
