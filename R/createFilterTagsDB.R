#' create a tag database for use by the dta2sg function in the sensorgnome
#' package
#'
#' (Deprecated)
#'
#' End users who wish to filter .DTA files themselves can use the database
#' generated by this function.  It will include all tags whose activation overlaps
#' the specified time interval.
#'
#' @param ts real vector of length 2; start and end timestamps;  any tag
#' active during the time period is included in the output database.
#'
#' @param outFile name of output file for database
#'
#' @return the number of tags in the database
#'
#' @note the output database is a .csv file with these columns:
#' \itemize{
#' \item proj: character name of project
#' \item id: Lotek id tag ID, but possibly with a fractional part to distinguish
#' tags with different BI from the same project; e.g. 123.1
#' \item tagFreq: floating point nominal tag frequency, in MHz
#' \item bi: floating point burst interval, in seconds
#' }
#' sorted in order by id and bi within project.
#'
#' @export
#'
#' @author John Brzustowski \email{jbrzusto@@REMOVE_THIS_PART_fastmail.fm}

createFilterTagsDB = function(tsRange, outFile) {

    tsRange = as.numeric(tsRange)

    meta = safeSQL(getMotusMetaDB())

    ## grab tags with deployment periods overlapping the date range
    tags = meta("
select
   ifnull(t3.label, 'NA') as proj,
   t2.mfgID               as id,
   t2.nomFreq             as tagFreq,
   t2.period              as bi
from
   tagDeps as t1
join
   tags as t2 on t1.tagID=t2.tagID
join
   projs as t3 on t1.projectID=t3.id
where
   t1.tsEnd >= :ts1 and t1.tsStart <= :ts2
group by
   t1.tagID
order by
   t1.tsStart
", ts1=tsRange[1], ts2=tsRange[2])

    ## Remove conflicting tags, since the filter_tags version of the
    ## tag finder doesn't properly handle ambiguous detections; due to
    ## the "order by" clause in the query above, priority is given to
    ## the earliest deployed tag in any group of conflicting tags.
    ## And because tag BI are probably only factory-specified to a
    ## precisision of 0.01 seconds, we round bi to 2 decimal places.
    ##
    ## Such issues are why this approach is obsolete.

    tags = subset(tags, ! duplicated(paste(round(as.numeric(id)), round(bi, 2))))
    tags$id = as.numeric(tags$id)
    tags$bi = round(tags$bi,4)

    ## there might still be tags with
    write.csv(tags[order(tags$proj,round(tags$id), tags$bi),], outFile, row.names=FALSE)

    return(nrow(tags))
}
