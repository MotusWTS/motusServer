#' create a tag database for use by the dta2sg function in the sensorgnome
#' package
#'
#' (Deprecated)
#'
#' End users who wish to filter .DTA files themselves can use the database
#' generated by this function.  It will include all tags whose activation overlaps
#' the specified time interval.
#'
#' @param ts real vector of length 2; start and end timestamps;  any tag
#' active during the time period is included in the output database.
#'
#' @param outFile name of output file for database
#'
#' @return the number of tags in the database
#'
#' @note the output database is a .csv file with these columns:
#' \itemize{
#' \item proj: character name of project
#' \item id: Lotek id tag ID, but possibly with a fractional part to distinguish
#' tags with different BI from the same project; e.g. 123.1
#' \item tagFreq: floating point nominal tag frequency, in MHz
#' \item bi: floating point burst interval, in seconds
#' }
#'
#' @export
#'
#' @author John Brzustowski \email{jbrzusto@@REMOVE_THIS_PART_fastmail.fm}

createFilterTagsDB = function(tsRange, outFile) {

    tsRange = as.numeric(tsRange)

    meta = safeSQL(getMotusMetaDB())

    ## grab tags with deployment periods overlapping the date range
    tags = meta("
select
   ifnull(t3.label, 'NA') as proj,
   t2.mfgID               as id,
   t2.nomFreq             as tagFreq,
   t2.period              as bi
from
   tagDeps as t1
join
   tags as t2 on t1.tagID=t2.tagID
join
   projs as t3 on t1.projectID=t3.id
where
   t1.tsEnd >= :ts1 and t1.tsStart <= :ts2
order by
   t1.tsStart
", ts1=tsRange[1], ts2=tsRange[2])

    ## remove conflicting tags, since the filter_tags version of the
    ## tag finder can't handle ambiguous detections; due to the "order
    ## by" clause in the query above, priority is given to the
    ## earliest deployed tag in any group of conflicting tags.  And
    ## because tag BI are probably only factory-specified to a
    ## precisision of 0.01 seconds, we round bi to 2 decimal places.

    tags = subset(tags, ! duplicated(paste(id, round(bi, 3))))
    tags$id = as.numeric(tags$id)
    write.csv(tags, outFile, row.names=FALSE)

    return(nrow(tags))
}
